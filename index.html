<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑù</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, system-ui, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.2em; margin-bottom: 8px; font-weight: 700; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .content { padding: 30px; }
        .input-section { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px; }
        .input-box { background: #f8f9fa; border-radius: 12px; padding: 20px; border: 2px solid #e9ecef; transition: border-color 0.3s; }
        .input-box:focus-within { border-color: #4facfe; }
        .input-title { font-size: 1.1em; font-weight: 600; margin-bottom: 12px; color: #495057; display: flex; align-items: center; gap: 8px; }
        .textarea { width: 100%; height: 200px; padding: 14px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Pretendard Variable', Pretendard, monospace; font-size: 13px; line-height: 1.5; resize: vertical; outline: none; transition: border-color 0.3s; }
        .textarea:focus { border-color: #4facfe; box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1); }
        .count { margin-top: 8px; font-size: 0.85em; color: #6c757d; font-weight: 500; }
        .compare-section { text-align: center; margin-bottom: 30px; }
        .compare-btn { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; padding: 16px 40px; border-radius: 25px; font-size: 1.1em; font-weight: 600; cursor: pointer; transition: all 0.3s; box-shadow: 0 8px 16px rgba(79, 172, 254, 0.3); }
        .compare-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(79, 172, 254, 0.4); }
        .compare-btn:disabled { background: #6c757d; cursor: not-allowed; transform: none; box-shadow: none; }
        .results { display: none; }
        .results.show { display: block; animation: fadeIn 0.5s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .controls { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 15px 20px; border-radius: 12px; border: 1px solid #dee2e6; }
        .filter-group { display: flex; background: white; border-radius: 20px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .filter-btn { padding: 10px 20px; border: none; background: white; color: #6c757d; cursor: pointer; font-weight: 500; transition: all 0.3s; font-size: 0.9em; }
        .filter-btn.active { background: #4facfe; color: white; }
        .filter-btn:hover:not(.active) { background: #f8f9fa; }
        .summary-stats { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin: 0 auto; flex: 1; max-width: 600px; }
        .stat-card { background: white; padding: 12px 16px; border-radius: 10px; text-align: center; border-left: 4px solid; box-shadow: 0 3px 10px rgba(0,0,0,0.08); transition: transform 0.3s; min-width: 80px; flex: 1; }
        .stat-card:hover { transform: translateY(-2px); }
        .stat-card.total { border-left-color: #007bff; }
        .stat-card.added { border-left-color: #28a745; }
        .stat-card.deleted { border-left-color: #dc3545; }
        .stat-card.modified { border-left-color: #ffc107; }
        .stat-card.urgent { border-left-color: #dc3545; background: #fff5f5; }
        .stat-number { font-size: 1.6em; font-weight: 700; margin-bottom: 3px; color: #495057; }
        .stat-label { font-size: 0.75em; color: #6c757d; font-weight: 500; }
        .copy-btn { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: 500; transition: all 0.3s; font-size: 0.9em; }
        .copy-btn:hover { background: #218838; transform: translateY(-1px); }
        .results-list { max-height: 70vh; overflow-y: auto; padding-right: 8px; }
        .results-list::-webkit-scrollbar { width: 6px; }
        .results-list::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 8px; }
        .results-list::-webkit-scrollbar-thumb { background: #4facfe; border-radius: 8px; }
        .result-item { margin-bottom: 15px; border-radius: 8px; overflow: hidden; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 1px solid #e0e0e0; background: white; }
        .result-item:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .result-item.added { border-left: 3px solid #28a745; }
        .result-item.deleted { border-left: 3px solid #dc3545; }
        .result-item.modified { border-left: 3px solid #ffc107; }
        .result-item.page-changed { border-left: 3px solid #007bff; }
        .result-item.unchanged { border-left: 3px solid #6c757d; }
        .result-header { padding: 10px 18px; font-weight: 600; font-size: 1em; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-bottom: 1px solid #e0e0e0; color: #2c3e50; }
        .result-body { padding: 15px 18px; background: white; }
        .change-box { margin-bottom: 16px; padding: 16px 18px; border-radius: 6px; font-family: 'Pretendard Variable', Pretendard, sans-serif; font-size: 14px; line-height: 1.5; font-weight: 500; color: #1a1a1a; border: 2px solid; letter-spacing: -0.02em; }
        .change-box:last-child { margin-bottom: 0; }
        .change-box.old { background: #ffffff; border-color: #ff4444; }
        .change-box.new { background: #ffffff; border-color: #44aa44; }
        .change-box.info { background: #ffffff; border-color: #4488ff; margin-top: 16px; }
        .change-box.same { background: #ffffff; border-color: #999999; }
        .change-label { font-weight: 600; margin-right: 8px; font-size: 13px; color: #2c2c2c; letter-spacing: -0.01em; }
        .original-text { font-family: 'Pretendard Variable', Pretendard, -apple-system, sans-serif; font-size: 14px; font-weight: 600; color: #1a1a1a; background: #f8f9fa; padding: 6px 10px; border-radius: 4px; display: inline-block; border: 1px solid #e9ecef; letter-spacing: -0.015em; line-height: 1.4; }
        .change-tags { margin-top: 14px; display: flex; flex-wrap: wrap; gap: 8px; }
        .change-tag { background: #2c3e50; color: #ffffff; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 600; border: none; box-shadow: 0 2px 4px rgba(44, 62, 80, 0.3); letter-spacing: -0.01em; }
        .urgent-badge { background: #e74c3c; color: white; padding: 4px 10px; border-radius: 10px; font-size: 12px; font-weight: 600; box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3); letter-spacing: -0.01em; }
        .no-results { text-align: center; padding: 60px 20px; color: #6c757d; }
        .no-results-icon { font-size: 3em; margin-bottom: 15px; }
        .no-results-title { font-size: 1.3em; font-weight: 600; margin-bottom: 8px; }
        .tips { background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); padding: 25px; border-radius: 12px; margin-top: 30px; border: 1px solid #bbdefb; }
        .tips h4 { color: #1565c0; font-size: 1.1em; margin-bottom: 15px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .tips-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; }
        .tip-item { display: flex; align-items: flex-start; gap: 8px; color: #1976d2; font-weight: 400; font-size: 0.9em; }
        .tip-icon { color: #4facfe; font-weight: 600; }
        @media (max-width: 768px) { .input-section { grid-template-columns: 1fr; gap: 20px; } .controls { flex-direction: column; gap: 15px; } .summary-stats { max-width: 100%; } .stat-card { min-width: 70px; } .tips-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìö Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑù</h1>
            <p>HWP/PDF Î™©Ï∞® Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ Ìé∏ÏßëÏûê ÏàòÏ§ÄÏúºÎ°ú Ï†ïÎ∞Ä Î∂ÑÏÑùÌï©ÎãàÎã§</p>
        </div>
        <div class="content">
            <div class="input-section">
                <div class="input-box">
                    <div class="input-title">üìÑ Í∏∞Ï°¥ Î™©Ï∞®</div>
                    <textarea id="oldTOC" class="textarea" placeholder="Í∏∞Ï°¥ Î™©Ï∞®Î•º Ïó¨Í∏∞Ïóê Î∂ôÏó¨ÎÑ£Ïñ¥Ï£ºÏÑ∏Ïöî.

ÏòàÏãú:
Ï†ú1Ïû• ÏÑúÎ°† ........................... 1
Ï†ú2Ïû• Ïù¥Î°†Ï†Å Î∞∞Í≤Ω .................... 15
  2.1 ÏÑ†ÌñâÏó∞Íµ¨ ....................... 16
  2.2 Ïó∞Íµ¨Î™®Ìòï ....................... 25
Ï†ú3Ïû• Ïó∞Íµ¨Î∞©Î≤ï ....................... 35"></textarea>
                    <div class="count" id="oldCount">0Ï§Ñ</div>
                </div>
                <div class="input-box">
                    <div class="input-title">üìù ÏÉàÎ°úÏö¥ Î™©Ï∞®</div>
                    <textarea id="newTOC" class="textarea" placeholder="ÏÉàÎ°úÏö¥ Î™©Ï∞®Î•º Ïó¨Í∏∞Ïóê Î∂ôÏó¨ÎÑ£Ïñ¥Ï£ºÏÑ∏Ïöî.

ÏòàÏãú:
Ï†ú1Ïû• ÏÑúÎ°† ........................... 1
Ï†ú2Ïû• Ïù¥Î°†Ï†Å Î∞∞Í≤Ω Î∞è ÏÑ†ÌñâÏó∞Íµ¨ ........ 15
  2.1 ÏÑ†ÌñâÏó∞Íµ¨ Í≤ÄÌÜ† .................. 16
  2.2 Ïó∞Íµ¨Î™®Ìòï ÏÑ§Ï†ï .................. 25
Ï†ú3Ïû• Ïó∞Íµ¨Î∞©Î≤ïÎ°† ..................... 35
Ï†ú4Ïû• Ïó∞Íµ¨Í≤∞Í≥º ....................... 50"></textarea>
                    <div class="count" id="newCount">0Ï§Ñ</div>
                </div>
            </div>
            <div class="compare-section">
                <button class="compare-btn" id="compareBtn">üîç Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑù ÏãúÏûë</button>
            </div>
            <div class="results" id="results">
                <div class="controls">
                    <div class="filter-group">
                        <button class="filter-btn active" data-filter="changes">Î≥ÄÍ≤ΩÏÇ¨Ìï≠</button>
                        <button class="filter-btn" data-filter="all">Ï†ÑÏ≤¥</button>
                        <button class="filter-btn" data-filter="urgent">Í∏¥Í∏âÍ≤ÄÌÜ†</button>
                    </div>
                    <div class="summary-stats">
                        <div class="stat-card total"><div class="stat-number" id="totalCount">0</div><div class="stat-label">Ï¥ù Ìï≠Î™©</div></div>
                        <div class="stat-card added"><div class="stat-number" id="addedCount">0</div><div class="stat-label">‚ûï Ï∂îÍ∞Ä</div></div>
                        <div class="stat-card deleted"><div class="stat-number" id="deletedCount">0</div><div class="stat-label">‚ûñ ÏÇ≠Ï†ú</div></div>
                        <div class="stat-card modified"><div class="stat-number" id="modifiedCount">0</div><div class="stat-label">‚úèÔ∏è ÏàòÏ†ï</div></div>
                        <div class="stat-card urgent"><div class="stat-number" id="urgentCount">0</div><div class="stat-label">üö® Í∏¥Í∏â</div></div>
                    </div>
                    <button class="copy-btn" id="copyBtn">üìã Í≤∞Í≥º Î≥µÏÇ¨</button>
                </div>
                <div class="results-list" id="resultsList"></div>
            </div>
            <div class="tips">
                <h4>üí° Ìé∏ÏßëÏûê ÏàòÏ§Ä Î∂ÑÏÑù Í∏∞Îä•</h4>
                <div class="tips-grid">
                    <div class="tip-item"><span class="tip-icon">‚ñ∂</span><span>ÎùÑÏñ¥Ïì∞Í∏∞, Î¨∏Ïû•Î∂ÄÌò∏, Ï°∞ÏÇ¨ Î≥ÄÍ≤ΩÍπåÏßÄ Ï†ïÎ∞Ä Í∞êÏßÄ</span></div>
                    <div class="tip-item"><span class="tip-icon">‚ñ∂</span><span>ÌïúÏûêÌëúÍ∏∞, Ïô∏ÎûòÏñ¥ ÌëúÍ∏∞Î≤ï, Ï†ÑÎ¨∏Ïö©Ïñ¥ Î≥ÄÍ≤Ω Î∂ÑÏÑù</span></div>
                    <div class="tip-item"><span class="tip-icon">‚ñ∂</span><span>Îã®Ïñ¥ Ï∂îÍ∞Ä/ÏÇ≠Ï†ú/ÏàúÏÑúÎ≥ÄÍ≤Ω, Ïñ¥ÎØ∏ Î≥ÄÌôî Í∞êÏßÄ</span></div>
                    <div class="tip-item"><span class="tip-icon">‚ñ∂</span><span>ÍµêÏ†ïÍµêÏó¥ Ï†ÑÎ¨∏Í∞Ä ÏàòÏ§ÄÏùò ÏÑ∏Î∞ÄÌïú ÌÖçÏä§Ìä∏ ÎπÑÍµê</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let analysisResults = [];
        let currentFilter = 'changes';

        document.addEventListener('DOMContentLoaded', function() {
            const oldTOC = document.getElementById('oldTOC');
            const newTOC = document.getElementById('newTOC');
            const compareBtn = document.getElementById('compareBtn');
            const copyBtn = document.getElementById('copyBtn');
            const filterBtns = document.querySelectorAll('.filter-btn');

            oldTOC.addEventListener('input', () => updateLineCount('oldTOC', 'oldCount'));
            newTOC.addEventListener('input', () => updateLineCount('newTOC', 'newCount'));
            compareBtn.addEventListener('click', startComparison);
            copyBtn.addEventListener('click', copyResults);

            filterBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setFilter(e.target.dataset.filter);
                });
            });

            updateLineCount('oldTOC', 'oldCount');
            updateLineCount('newTOC', 'newCount');
        });

        function updateLineCount(textareaId, countId) {
            const textarea = document.getElementById(textareaId);
            const lines = textarea.value.split('\n').filter(line => line.trim().length > 0);
            document.getElementById(countId).textContent = lines.length + 'Ï§Ñ';
        }

        function parseTOC(text) {
            if (!text.trim()) return [];
            // Îπà Ï§Ñ Ï†úÍ±∞ Î∞è Ïó∞ÏÜçÎêú Í≥µÎ∞± Ï†ïÎ¶¨
            const lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            return lines.map((line, index) => {
                const trimmed = line.trim();
                const indent = line.length - line.trimStart().length;
                const level = Math.floor(indent / 2);
                const patterns = [/^(.+?)\s*[\.]{2,}\s*(\d+)$/, /^(.+?)\s{3,}(\d+)$/, /^(.+?)\t+(\d+)$/, /^(.+?)\s*\((\d+)\)$/, /^(.+?)\s*[-~]\s*(\d+)$/];
                let title = '', page = '';
                for (const pattern of patterns) {
                    const match = trimmed.match(pattern);
                    if (match) { title = match[1].trim(); page = match[2]; break; }
                }
                if (!title) title = trimmed;
                title = title.replace(/^[\d\.\-\s]*/, '').trim().replace(/[\.]{2,}$/, '').trim();
                return { index, title, page, level, original: trimmed };
            });
        }

        function calculateSimilarity(str1, str2) {
            if (str1 === str2) return 1.0;
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    if (str1[i - 1] === str2[j - 1]) matrix[j][i] = matrix[j - 1][i - 1];
                    else matrix[j][i] = Math.min(matrix[j - 1][i - 1] + 1, matrix[j][i - 1] + 1, matrix[j - 1][i] + 1);
                }
            }
            return matrix[str2.length][str1.length];
        }

        function detectParticleChanges(oldText, newText) {
            const changes = [];
            const particles = [
                {old: 'ÏùÄ', new: 'Îäî', desc: 'Ï£ºÍ≤©Ï°∞ÏÇ¨'},
                {old: 'Ïù¥', new: 'Í∞Ä', desc: 'Ï£ºÍ≤©Ï°∞ÏÇ¨'},
                {old: 'ÏùÑ', new: 'Î•º', desc: 'Î™©Ï†ÅÍ≤©Ï°∞ÏÇ¨'},
                {old: 'ÏôÄ', new: 'Í≥º', desc: 'Ï†ëÏÜçÏ°∞ÏÇ¨'},
                {old: 'Î°ú', new: 'ÏúºÎ°ú', desc: 'Î∂ÄÏÇ¨Í≤©Ï°∞ÏÇ¨'}
            ];
            
            particles.forEach(({old, new: newParticle, desc}) => {
                if (oldText.includes(old) && newText.includes(newParticle)) {
                    changes.push(`${desc} Î≥ÄÍ≤Ω (${old}‚Üí${newParticle})`);
                } else if (oldText.includes(newParticle) && newText.includes(old)) {
                    changes.push(`${desc} Î≥ÄÍ≤Ω (${newParticle}‚Üí${old})`);
                }
            });
            
            return changes;
        }

        function detectEndingChanges(oldText, newText) {
            const changes = [];
            const endings = [
                {old: 'ÏäµÎãàÎã§', new: '„ÖÇÎãàÎã§', desc: 'ÏÑúÏà†Ïñ¥ÎØ∏'},
                {old: 'ÌñàÎã§', new: 'ÌïòÏòÄÎã§', desc: 'Í≥ºÍ±∞Ìòï'},
                {old: 'ÌïúÎã§', new: 'Ìï®', desc: 'ÌòÑÏû¨Ìòï'},
                {old: 'Í≤ÉÏù¥Îã§', new: 'Í≤ÉÏûÑ', desc: 'ÏÑúÏà†Ìòï'},
                {old: 'ÎêòÏóàÎã§', new: 'ÎêêÎã§', desc: 'Ï∂ïÏïΩÌòï'}
            ];
            
            endings.forEach(({old, new: newEnding, desc}) => {
                if (oldText.includes(old) && newText.includes(newEnding)) {
                    changes.push(`${desc} Î≥ÄÍ≤Ω (${old}‚Üí${newEnding})`);
                } else if (oldText.includes(newEnding) && newText.includes(old)) {
                    changes.push(`${desc} Î≥ÄÍ≤Ω (${newEnding}‚Üí${old})`);
                }
            });
            
            return changes;
        }

        function analyzeWordChanges(oldText, newText) {
            const changes = [];
            const oldWords = oldText.split(/[\s\.,\(\)]+/).filter(w => w.length > 0);
            const newWords = newText.split(/[\s\.,\(\)]+/).filter(w => w.length > 0);
            
            const addedWords = newWords.filter(word => !oldWords.includes(word));
            if (addedWords.length > 0) {
                changes.push(`Îã®Ïñ¥ Ï∂îÍ∞Ä: "${addedWords.join(', ')}"`);
            }
            
            const deletedWords = oldWords.filter(word => !newWords.includes(word));
            if (deletedWords.length > 0) {
                changes.push(`Îã®Ïñ¥ ÏÇ≠Ï†ú: "${deletedWords.join(', ')}"`);
            }
            
            const commonWords = oldWords.filter(word => newWords.includes(word));
            if (commonWords.length > 1) {
                const oldOrder = commonWords.map(word => oldWords.indexOf(word));
                const newOrder = commonWords.map(word => newWords.indexOf(word));
                if (JSON.stringify(oldOrder) !== JSON.stringify(newOrder)) {
                    changes.push('Îã®Ïñ¥ ÏàúÏÑú Î≥ÄÍ≤Ω');
                }
            }
            
            return changes;
        }

        function detectNotationChanges(oldText, newText) {
            const changes = [];
            
            const foreignWords = [
                {old: 'Ïª¥Ìì®ÌÑ∞', new: 'computer', desc: 'Ïô∏ÎûòÏñ¥‚ÜíÏòÅÎ¨∏'},
                {old: 'computer', new: 'Ïª¥Ìì®ÌÑ∞', desc: 'ÏòÅÎ¨∏‚ÜíÏô∏ÎûòÏñ¥'},
                {old: 'Îç∞Ïù¥ÌÉÄ', new: 'Îç∞Ïù¥ÌÑ∞', desc: 'Ïô∏ÎûòÏñ¥ ÌëúÍ∏∞Î≤ï'},
                {old: 'ÌîÑÎ°úÍ∑∏Îû®', new: 'ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç', desc: 'Ïô∏ÎûòÏñ¥ ÌôúÏö©Ìòï'},
                {old: 'ÏãúÏä§ÌÖú', new: 'Ï≤¥Í≥Ñ', desc: 'Ïô∏ÎûòÏñ¥‚ÜíÏàúÏö∞Î¶¨Îßê'},
                {old: 'Îß§ÎãàÏ†∏', new: 'Îß§ÎãàÏ†Ä', desc: 'Ïô∏ÎûòÏñ¥ ÌëúÍ∏∞Î≤ï'}
            ];
            
            foreignWords.forEach(({old, new: newWord, desc}) => {
                if (oldText.includes(old) && newText.includes(newWord)) {
                    changes.push(`${desc} (${old}‚Üí${newWord})`);
                }
            });
            
            const terminology = [
                {old: 'Î∂ÑÏÑù', new: 'Ìï¥ÏÑù', desc: 'Ïö©Ïñ¥ ÏÑ†ÌÉù'},
                {old: 'Î∞©Î≤ï', new: 'Î∞©Î≤ïÎ°†', desc: 'ÌïôÏà†Ï†Å ÌëúÌòÑ'},
                {old: 'Ïó∞Íµ¨', new: 'Ï°∞ÏÇ¨', desc: 'Ïö©Ïñ¥ Ï†ïÎ∞ÄÌôî'},
                {old: 'Í≤∞Í≥º', new: 'ÏÑ±Í≥º', desc: 'ÎâòÏïôÏä§ Î≥ÄÍ≤Ω'}
            ];
            
            terminology.forEach(({old, new: newTerm, desc}) => {
                if (oldText.includes(old) && newText.includes(newTerm)) {
                    changes.push(`${desc} (${old}‚Üí${newTerm})`);
                }
            });
            
            return changes;
        }

        function analyzeNumberChanges(oldItem, newItem) {
            const changes = [];
            
            const chapterPatterns = [/Ï†ú?(\d+)Ïû•/g, /Ï†ú(\d+)/g];
            let foundChapterChange = false;
            
            for (const pattern of chapterPatterns) {
                const oldNumbers = oldItem.title.match(pattern);
                const newNumbers = newItem.title.match(pattern);
                
                if (oldNumbers && newNumbers && oldNumbers[0] !== newNumbers[0] && !foundChapterChange) {
                    const oldNum = oldNumbers[0].match(/\d+/)[0];
                    const newNum = newNumbers[0].match(/\d+/)[0];
                    changes.push(`Ïû• Î≤àÌò∏ Î≥ÄÍ≤Ω (${oldNum}‚Üí${newNum})`);
                    foundChapterChange = true;
                    break;
                }
            }
            
            const otherPatterns = [
                { pattern: /(\d+)Ï†à/g, name: 'Ï†à' },
                { pattern: /(\d+)Ìï≠/g, name: 'Ìï≠' },
                { pattern: /(\d+)Î∂Ä/g, name: 'Î∂Ä' },
                { pattern: /(\d+)Ï∞®/g, name: 'Ï∞®' },
                { pattern: /(\d+)Ìé∏/g, name: 'Ìé∏' }
            ];
            
            otherPatterns.forEach(({ pattern, name }) => {
                const oldNumbers = oldItem.title.match(pattern);
                const newNumbers = newItem.title.match(pattern);
                if (oldNumbers && newNumbers && oldNumbers[0] !== newNumbers[0]) {
                    const oldNum = oldNumbers[0].match(/\d+/)[0];
                    const newNum = newNumbers[0].match(/\d+/)[0];
                    changes.push(`${name} Î≤àÌò∏ Î≥ÄÍ≤Ω (${oldNum}‚Üí${newNum})`);
                }
            });
            
            return changes;
        }
        
        function analyzeChanges(oldItem, newItem) {
            const changes = [];
            const oldText = oldItem.title;
            const newText = newItem.title;
            
            if (oldText === newText) {
                // Ï†úÎ™©Ïù¥ Í∞ôÏúºÎ©¥ ÌéòÏù¥ÏßÄ Î≥ÄÍ≤ΩÎßå ÌôïÏù∏
                if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                    changes.push(`ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω (${oldItem.page}‚Üí${newItem.page})`);
                }
                return changes;
            }
            
            // Ï†úÎ™©Ïù¥ Îã§Î•¥Î©¥ ÏÉÅÏÑ∏ Î∂ÑÏÑù
            const detailChanges = analyzeDetailChanges(oldText, newText);
            changes.push(...detailChanges);
            
            // ÌéòÏù¥ÏßÄÎèÑ Îã§Î•¥Î©¥ Ï∂îÍ∞Ä
            if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                changes.push(`ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω (${oldItem.page}‚Üí${newItem.page})`);
            }
            
            return changes.length > 0 ? changes : ['ÎÇ¥Ïö© ÏàòÏ†ï'];
        }

        function analyzeDetailChanges(oldText, newText) {
            const changes = [];
            
            // Îã®Ïñ¥ Îã®ÏúÑÎ°ú Î∂ÑÏÑùÌïòÏó¨ Ï†ïÌôïÌïú Î≥ÄÍ≤Ω Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
            const oldWords = oldText.split(/\s+/);
            const newWords = newText.split(/\s+/);
            
            // Í∞ÄÏû• Í∏¥ Í≥µÌÜµ Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
            const commonPrefix = findCommonPrefix(oldWords, newWords);
            const commonSuffix = findCommonSuffix(oldWords, newWords);
            
            // Î≥ÄÍ≤ΩÎêú Î∂ÄÎ∂Ñ Ï∂îÏ∂ú
            const oldChanged = oldWords.slice(commonPrefix.length, oldWords.length - commonSuffix.length);
            const newChanged = newWords.slice(commonPrefix.length, newWords.length - commonSuffix.length);
            
            if (oldChanged.length > 0 || newChanged.length > 0) {
                const oldPart = oldChanged.join(' ') || '';
                const newPart = newChanged.join(' ') || '';
                
                if (oldPart && newPart) {
                    changes.push(`ÎÇ¥Ïö©ÏàòÏ†ï: ${oldPart}‚Üí${newPart}`);
                } else if (oldPart && !newPart) {
                    changes.push(`ÏÇ≠Ï†ú: ${oldPart}`);
                } else if (!oldPart && newPart) {
                    changes.push(`Ï∂îÍ∞Ä: ${newPart}`);
                }
            }
            
            // ÎßåÏïΩ Îã®Ïñ¥ Îã®ÏúÑÎ°ú Ï∞æÏßÄ Î™ªÌñàÎã§Î©¥ Î¨∏Ïûê Îã®ÏúÑÎ°ú Î∂ÑÏÑù
            if (changes.length === 0 && oldText !== newText) {
                const charChanges = findCharacterChanges(oldText, newText);
                if (charChanges) {
                    changes.push(charChanges);
                }
            }
            
            return changes;
        }

        function findCommonPrefix(arr1, arr2) {
            const common = [];
            const minLength = Math.min(arr1.length, arr2.length);
            for (let i = 0; i < minLength; i++) {
                if (arr1[i] === arr2[i]) {
                    common.push(arr1[i]);
                } else {
                    break;
                }
            }
            return common;
        }

        function findCommonSuffix(arr1, arr2) {
            const common = [];
            const minLength = Math.min(arr1.length, arr2.length);
            for (let i = 0; i < minLength; i++) {
                const oldIndex = arr1.length - 1 - i;
                const newIndex = arr2.length - 1 - i;
                if (arr1[oldIndex] === arr2[newIndex]) {
                    common.unshift(arr1[oldIndex]);
                } else {
                    break;
                }
            }
            return common;
        }

        function findCharacterChanges(oldText, newText) {
            // Î¨∏Ïûê Îã®ÏúÑÎ°ú ÎπÑÍµêÌïòÏó¨ Í∞ÄÏû• ÏûëÏùÄ Î≥ÄÍ≤Ω Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
            let start = 0;
            let end = 0;
            
            // ÏïûÏóêÏÑúÎ∂ÄÌÑ∞ Í∞ôÏùÄ Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
            while (start < oldText.length && start < newText.length && oldText[start] === newText[start]) {
                start++;
            }
            
            // Îí§ÏóêÏÑúÎ∂ÄÌÑ∞ Í∞ôÏùÄ Î∂ÄÎ∂Ñ Ï∞æÍ∏∞
            while (end < oldText.length - start && end < newText.length - start && 
                   oldText[oldText.length - 1 - end] === newText[newText.length - 1 - end]) {
                end++;
            }
            
            const oldChanged = oldText.slice(start, oldText.length - end);
            const newChanged = newText.slice(start, newText.length - end);
            
            if (oldChanged && newChanged) {
                return `ÎÇ¥Ïö©ÏàòÏ†ï: ${oldChanged}‚Üí${newChanged}`;
            } else if (oldChanged) {
                return `ÏÇ≠Ï†ú: ${oldChanged}`;
            } else if (newChanged) {
                return `Ï∂îÍ∞Ä: ${newChanged}`;
            }
            
            return null;
        }

        function analyzeTextChanges(oldText, newText) {
            const changes = [];
            
            if (oldText === newText) return [];
            
            const oldSpaces = oldText.replace(/[^\s]/g, '');
            const newSpaces = newText.replace(/[^\s]/g, '');
            if (oldSpaces !== newSpaces) {
                changes.push('ÎùÑÏñ¥Ïì∞Í∏∞ ÏàòÏ†ï');
            }
            
            const oldPunct = oldText.replace(/[^\.,!?;:()]/g, '');
            const newPunct = newText.replace(/[^\.,!?;:()]/g, '');
            if (oldPunct !== newPunct) {
                changes.push('Î¨∏Ïû•Î∂ÄÌò∏ ÏàòÏ†ï');
            }
            
            const hanjaPattern = /[‰∏Ä-ÈæØ]/;
            const oldHasHanja = hanjaPattern.test(oldText);
            const newHasHanja = hanjaPattern.test(newText);
            if (oldHasHanja !== newHasHanja) {
                if (newHasHanja) changes.push('ÌïúÏûê ÌëúÍ∏∞ Ï∂îÍ∞Ä');
                else changes.push('ÌïúÏûê ÌëúÍ∏∞ Ï†úÍ±∞');
            }
            
            const particleChanges = detectParticleChanges(oldText, newText);
            changes.push(...particleChanges);
            
            const endingChanges = detectEndingChanges(oldText, newText);
            changes.push(...endingChanges);
            
            const wordChanges = analyzeWordChanges(oldText, newText);
            changes.push(...wordChanges);
            
            const notationChanges = detectNotationChanges(oldText, newText);
            changes.push(...notationChanges);
            
            return changes;
        }

        function analyzePageChanges(oldItem, newItem) {
            const changes = [];
            
            if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                const oldPageNum = parseInt(oldItem.page);
                const newPageNum = parseInt(newItem.page);
                const pageDiff = Math.abs(newPageNum - oldPageNum);
                
                if (pageDiff > 20) {
                    changes.push(`ÌéòÏù¥ÏßÄ ÎåÄÌè≠ Î≥ÄÍ≤Ω (${oldItem.page}‚Üí${newItem.page})`);
                } else if (pageDiff > 5) {
                    changes.push(`ÌéòÏù¥ÏßÄ ÏÉÅÎãπ Î≥ÄÍ≤Ω (${oldItem.page}‚Üí${newItem.page})`);
                } else {
                    changes.push(`ÌéòÏù¥ÏßÄ ÏÜåÌè≠ Î≥ÄÍ≤Ω (${oldItem.page}‚Üí${newItem.page})`);
                }
            }
            
            return changes;
        }
        
        function compareItems(oldItems, newItems) {
            const results = [];
            const usedOld = new Set();
            const usedNew = new Set();
            
            // 1Îã®Í≥Ñ: Ï†úÎ™©Í≥º ÏàúÏÑúÍ∞Ä ÏôÑÏ†ÑÌûà ÏùºÏπòÌïòÎäî Ìï≠Î™©Îì§ Îß§Ïπ≠
            oldItems.forEach((oldItem, oldIndex) => {
                if (oldIndex < newItems.length) {
                    const newItem = newItems[oldIndex];
                    if (oldItem.title === newItem.title) {
                        usedOld.add(oldIndex);
                        usedNew.add(oldIndex);
                        const changes = [];
                        if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                            changes.push(`ÌéòÏù¥ÏßÄ ${oldItem.page} ‚Üí ${newItem.page}`);
                        }
                        results.push({ 
                            type: changes.length > 0 ? 'page-changed' : 'unchanged', 
                            oldItem, 
                            newItem, 
                            changes, 
                            severity: 'low', 
                            position: oldIndex 
                        });
                    }
                }
            });
            
            // 2Îã®Í≥Ñ: Ï†úÎ™©Ïù¥ Í∞ôÏßÄÎßå ÏúÑÏπòÍ∞Ä Îã§Î•∏ Ìï≠Î™©Îì§ Îß§Ïπ≠
            oldItems.forEach((oldItem, oldIndex) => {
                if (usedOld.has(oldIndex)) return;
                
                for (let newIndex = 0; newIndex < newItems.length; newIndex++) {
                    if (usedNew.has(newIndex)) continue;
                    
                    const newItem = newItems[newIndex];
                    if (oldItem.title === newItem.title) {
                        usedOld.add(oldIndex);
                        usedNew.add(newIndex);
                        const changes = ['ÏúÑÏπò Î≥ÄÍ≤Ω'];
                        if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                            changes.push(`ÌéòÏù¥ÏßÄ ${oldItem.page} ‚Üí ${newItem.page}`);
                        }
                        results.push({ 
                            type: 'page-changed', 
                            oldItem, 
                            newItem, 
                            changes, 
                            severity: 'medium', 
                            position: Math.min(oldIndex, newIndex) 
                        });
                        break;
                    }
                }
            });
            
            // 3Îã®Í≥Ñ: Ïú†ÏÇ¨Ìïú Ï†úÎ™©Ïùò Ìï≠Î™©Îì§ Îß§Ïπ≠ (70% Ïù¥ÏÉÅ Ïú†ÏÇ¨ÎèÑ)
            oldItems.forEach((oldItem, oldIndex) => {
                if (usedOld.has(oldIndex)) return;
                
                let bestMatch = null, bestSimilarity = 0, bestNewIndex = -1;
                newItems.forEach((newItem, newIndex) => {
                    if (usedNew.has(newIndex)) return;
                    const similarity = calculateSimilarity(oldItem.title.toLowerCase(), newItem.title.toLowerCase());
                    if (similarity > bestSimilarity && similarity > 0.7) {
                        bestMatch = newItem;
                        bestSimilarity = similarity;
                        bestNewIndex = newIndex;
                    }
                });
                
                if (bestMatch) {
                    usedOld.add(oldIndex);
                    usedNew.add(bestNewIndex);
                    const changes = analyzeChanges(oldItem, bestMatch);
                    results.push({ 
                        type: 'modified', 
                        oldItem, 
                        newItem: bestMatch, 
                        changes, 
                        severity: 'medium', 
                        position: Math.min(oldIndex, bestNewIndex) 
                    });
                }
            });
            
            // 4Îã®Í≥Ñ: ÏÇ≠Ï†úÎêú Ìï≠Î™©Îì§
            oldItems.forEach((oldItem, oldIndex) => {
                if (!usedOld.has(oldIndex)) {
                    results.push({ 
                        type: 'deleted', 
                        oldItem, 
                        newItem: null, 
                        changes: ['ÏÇ≠Ï†úÎê®'], 
                        severity: 'high', 
                        position: oldIndex 
                    });
                }
            });
            
            // 5Îã®Í≥Ñ: Ï∂îÍ∞ÄÎêú Ìï≠Î™©Îì§
            newItems.forEach((newItem, newIndex) => {
                if (!usedNew.has(newIndex)) {
                    results.push({ 
                        type: 'added', 
                        oldItem: null, 
                        newItem, 
                        changes: ['ÏÉàÎ°ú Ï∂îÍ∞ÄÎê®'], 
                        severity: 'medium', 
                        position: newIndex 
                    });
                }
            });
            
            return results.sort((a, b) => a.position - b.position);
        }

        function startComparison() {
            const oldText = document.getElementById('oldTOC').value;
            const newText = document.getElementById('newTOC').value;
            if (!oldText.trim() || !newText.trim()) { 
                alert('Í∏∞Ï°¥ Î™©Ï∞®ÏôÄ ÏÉàÎ°úÏö¥ Î™©Ï∞®Î•º Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'); 
                return; 
            }
            const btn = document.getElementById('compareBtn');
            btn.disabled = true;
            btn.textContent = 'üîÑ Î∂ÑÏÑùÏ§ë...';
            setTimeout(() => {
                const oldItems = parseTOC(oldText);
                const newItems = parseTOC(newText);
                analysisResults = compareItems(oldItems, newItems);
                displayResults();
                btn.disabled = false;
                btn.textContent = 'üîç Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑù ÏãúÏûë';
            }, 500);
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.classList.add('show');
            const stats = {
                total: analysisResults.length,
                added: analysisResults.filter(r => r.type === 'added').length,
                deleted: analysisResults.filter(r => r.type === 'deleted').length,
                modified: analysisResults.filter(r => r.type === 'modified' || r.type === 'page-changed').length,
                urgent: analysisResults.filter(r => r.severity === 'high').length
            };
            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('addedCount').textContent = stats.added;
            document.getElementById('deletedCount').textContent = stats.deleted;
            document.getElementById('modifiedCount').textContent = stats.modified;
            document.getElementById('urgentCount').textContent = stats.urgent;
            updateResultsList();
        }

        function setFilter(filter) {
            currentFilter = filter;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
            updateResultsList();
        }

        function updateResultsList() {
            const resultsListDiv = document.getElementById('resultsList');
            let filteredResults = analysisResults;
            if (currentFilter === 'changes') {
                filteredResults = analysisResults.filter(r => r.type !== 'unchanged');
            } else if (currentFilter === 'urgent') {
                filteredResults = analysisResults.filter(r => r.severity === 'high');
            }
            
            if (filteredResults.length === 0) {
                resultsListDiv.innerHTML = '<div class="no-results"><div class="no-results-icon">‚úÖ</div><div class="no-results-title">ÌëúÏãúÌï† Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§</div></div>';
                return;
            }
            
            resultsListDiv.innerHTML = filteredResults.map((result, index) => {
                const typeLabels = { 
                    'added': '‚ûï Ï∂îÍ∞ÄÎê®', 
                    'deleted': '‚ûñ ÏÇ≠Ï†úÎê®', 
                    'modified': '‚úèÔ∏è ÏàòÏ†ïÎê®', 
                    'page-changed': 'üìÑ ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω', 
                    'unchanged': '‚úÖ ÎèôÏùº' 
                };
                
                let bodyHtml = '';
                if (result.type === 'added') {
                    bodyHtml = `<div class="change-box new"><span class="change-label">ÏÉàÎ°ú Ï∂îÍ∞Ä:</span> <span class="original-text">${result.newItem.original}</span></div>`;
                } else if (result.type === 'deleted') {
                    bodyHtml = `<div class="change-box old"><span class="change-label">ÏÇ≠Ï†úÎê®:</span> <span class="original-text">${result.oldItem.original}</span></div>`;
                } else if (result.type === 'modified') {
                    let formattedChanges = '';
                    result.changes.forEach(change => {
                        if (change.startsWith('ÎÇ¥Ïö©ÏàòÏ†ï:')) {
                            const content = change.substring(5).trim();
                            if (content.includes('‚Üí')) {
                                const [before, after] = content.split('‚Üí');
                                formattedChanges += `<span class="change-item"><span class="change-tag">ÎÇ¥Ïö©ÏàòÏ†ï</span> <span class="change-content"><span class="change-before">${before.trim()}</span><span class="change-arrow"> ‚Üí </span><span class="change-after">${after.trim()}</span></span></span>`;
                            } else {
                                formattedChanges += `<span class="change-item"><span class="change-tag">ÎÇ¥Ïö©ÏàòÏ†ï</span> <span class="change-content">${content}</span></span>`;
                            }
                        } else if (change.startsWith('Ï∂îÍ∞Ä:')) {
                            const content = change.substring(3).trim();
                            formattedChanges += `<span class="change-item"><span class="change-tag">Ï∂îÍ∞Ä</span> <span class="change-content"><span class="change-after">${content}</span></span></span>`;
                        } else if (change.startsWith('ÏÇ≠Ï†ú:')) {
                            const content = change.substring(3).trim();
                            formattedChanges += `<span class="change-item"><span class="change-tag">ÏÇ≠Ï†ú</span> <span class="change-content"><span class="change-before">${content}</span></span></span>`;
                        } else {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        }
                    });
                    
                    bodyHtml = `
                        <div class="change-box old"><span class="change-label">Ïù¥Ï†Ñ ÎÇ¥Ïö©:</span> <span class="original-text">${result.oldItem.original}</span></div>
                        <div class="change-box new"><span class="change-label">ÏàòÏ†ïÎêú ÎÇ¥Ïö©:</span> <span class="original-text">${result.newItem.original}</span></div>
                        <div class="change-box info"><span class="change-label">üîç Î≥ÄÍ≤ΩÏÇ¨Ìï≠: </span>${formattedChanges}</div>
                    `;
                } else if (result.type === 'page-changed') {
                    let formattedChanges = '';
                    result.changes.forEach(change => {
                        if (change.startsWith('ÏúÑÏπò Î≥ÄÍ≤Ω')) {
                            formattedChanges += `<span class="change-item"><span class="change-tag">ÏúÑÏπò Î≥ÄÍ≤Ω</span></span>`;
                        } else if (change.startsWith('ÌéòÏù¥ÏßÄ')) {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        } else {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        }
                    });
                    
                    bodyHtml = `
                        <div class="change-box old"><span class="change-label">Ïù¥Ï†Ñ:</span> <span class="original-text">${result.oldItem.original}</span></div>
                        <div class="change-box new"><span class="change-label">Ïù¥ÌõÑ:</span> <span class="original-text">${result.newItem.original}</span></div>
                        <div class="change-box info"><span class="change-label">üîç Î≥ÄÍ≤ΩÏÇ¨Ìï≠: </span>${formattedChanges}</div>
                    `;
                } else {
                    bodyHtml = `<div class="change-box same"><span class="change-label">ÎèôÏùº:</span> <span class="original-text">${result.oldItem.original}</span></div>`;
                }
                
                return `<div class="result-item ${result.type}"><div class="result-header ${result.type}"><span>${typeLabels[result.type]} #${index + 1}</span>${result.severity === 'high' ? '<span class="urgent-badge">üö® Í∏¥Í∏â</span>' : ''}</div><div class="result-body">${bodyHtml}</div></div>`;
            }).join('');
        }

        // formatChanges Ìï®Ïàò Ï†úÍ±∞ (Ïù∏ÎùºÏù∏ÏúºÎ°ú Ï≤òÎ¶¨ÌïòÎØÄÎ°ú Î∂àÌïÑÏöî)

        function copyResults() {
            if (analysisResults.length === 0) { 
                alert('ÎπÑÍµê Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.'); 
                return; 
            }
            
            // ÌòÑÏû¨ ÌïÑÌÑ∞Ïóê Îî∞Îùº Í≤∞Í≥º ÌïÑÌÑ∞ÎßÅ
            let filteredResults = analysisResults;
            let filterLabel = 'Ï†ÑÏ≤¥';
            
            if (currentFilter === 'changes') {
                filteredResults = analysisResults.filter(r => r.type !== 'unchanged');
                filterLabel = 'Î≥ÄÍ≤ΩÏÇ¨Ìï≠';
            } else if (currentFilter === 'urgent') {
                filteredResults = analysisResults.filter(r => r.severity === 'high');
                filterLabel = 'Í∏¥Í∏âÍ≤ÄÌÜ†';
            }
            
            if (filteredResults.length === 0) {
                alert('ÌòÑÏû¨ ÌïÑÌÑ∞Ïóê Ìï¥ÎãπÌïòÎäî Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }
            
            let text = `Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑù Í≤∞Í≥º (${filterLabel})\nÏÉùÏÑ±ÏùºÏãú: ` + new Date().toLocaleString('ko-KR') + '\n\n';
            filteredResults.forEach((result, index) => {
                const typeLabels = { 
                    'added': '‚ûï Ï∂îÍ∞ÄÎê®', 
                    'deleted': '‚ûñ ÏÇ≠Ï†úÎê®', 
                    'modified': '‚úèÔ∏è ÏàòÏ†ïÎê®', 
                    'page-changed': 'üìÑ ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω', 
                    'unchanged': '‚úÖ ÎèôÏùº' 
                };
                
                text += `${index + 1}. ${typeLabels[result.type]}${result.severity === 'high' ? ' üö® Í∏¥Í∏â' : ''}\n`;
                if (result.oldItem) text += `   Í∏∞Ï°¥: ${result.oldItem.original}\n`;
                if (result.newItem) text += `   ÏÉàÎ°ú: ${result.newItem.original}\n`;
                if (result.changes && result.changes.length > 0) text += `   Î≥ÄÍ≤ΩÏÇ¨Ìï≠: ${result.changes.join(', ')}\n`;
                text += '\n';
            });
            
            text += '‚Äª Ìé∏ÏßëÏûê ÏàòÏ§Ä Î™©Ï∞® ÎπÑÍµê Î∂ÑÏÑùÍ∏∞ÏóêÏÑú ÏÉùÏÑ±Îê®';
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert(`${filterLabel} Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§! (${filteredResults.length}Í∞ú Ìï≠Î™©)`);
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!');
            } catch (err) {
                alert('Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÏàòÎèôÏúºÎ°ú Î≥µÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî.');
            }
            document.body.removeChild(textArea);
        }
    </script>
</body>
</html>
