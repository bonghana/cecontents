<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª©ì°¨ ë¹„êµ ë¶„ì„</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, system-ui, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.2em; margin-bottom: 8px; font-weight: 700; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .content { padding: 30px; }
        .input-section { display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-bottom: 25px; }
        .input-box { background: #f8f9fa; border-radius: 12px; padding: 20px; border: 2px solid #e9ecef; transition: border-color 0.3s; }
        .input-box:focus-within { border-color: #4facfe; }
        .input-title { font-size: 1.1em; font-weight: 600; margin-bottom: 12px; color: #495057; display: flex; align-items: center; gap: 8px; }
        .textarea { width: 100%; height: 200px; padding: 14px; border: 2px solid #dee2e6; border-radius: 8px; font-family: 'Pretendard Variable', Pretendard, monospace; font-size: 13px; line-height: 1.5; resize: vertical; outline: none; transition: border-color 0.3s; }
        .textarea:focus { border-color: #4facfe; box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1); }
        .count { margin-top: 8px; font-size: 0.85em; color: #6c757d; font-weight: 500; }
        .compare-section { text-align: center; margin-bottom: 30px; }
        .compare-btn { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; padding: 16px 40px; border-radius: 25px; font-size: 1.1em; font-weight: 600; cursor: pointer; transition: all 0.3s; box-shadow: 0 8px 16px rgba(79, 172, 254, 0.3); }
        .compare-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(79, 172, 254, 0.4); }
        .compare-btn:disabled { background: #6c757d; cursor: not-allowed; transform: none; box-shadow: none; }
        .results { display: none; }
        .results.show { display: block; animation: fadeIn 0.5s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .controls { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 15px 20px; border-radius: 12px; border: 1px solid #dee2e6; }
        .filter-group { display: flex; background: white; border-radius: 20px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .filter-btn { padding: 10px 20px; border: none; background: white; color: #6c757d; cursor: pointer; font-weight: 500; transition: all 0.3s; font-size: 0.9em; }
        .filter-btn.active { background: #4facfe; color: white; }
        .filter-btn:hover:not(.active) { background: #f8f9fa; }
        .summary-stats { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin: 0 auto; flex: 1; max-width: 600px; }
        .stat-card { background: white; padding: 12px 16px; border-radius: 10px; text-align: center; border-left: 4px solid; box-shadow: 0 3px 10px rgba(0,0,0,0.08); transition: transform 0.3s; min-width: 80px; flex: 1; }
        .stat-card:hover { transform: translateY(-2px); }
        .stat-card.total { border-left-color: #007bff; }
        .stat-card.added { border-left-color: #28a745; }
        .stat-card.deleted { border-left-color: #dc3545; }
        .stat-card.modified { border-left-color: #ffc107; }
        .stat-card.urgent { border-left-color: #dc3545; background: #fff5f5; }
        .stat-number { font-size: 1.6em; font-weight: 700; margin-bottom: 3px; color: #495057; }
        .stat-label { font-size: 0.75em; color: #6c757d; font-weight: 500; }
        .copy-btn { padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 20px; cursor: pointer; font-weight: 500; transition: all 0.3s; font-size: 0.9em; }
        .copy-btn:hover { background: #218838; transform: translateY(-1px); }
        .results-list { max-height: 70vh; overflow-y: auto; padding-right: 8px; }
        .results-list::-webkit-scrollbar { width: 6px; }
        .results-list::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 8px; }
        .results-list::-webkit-scrollbar-thumb { background: #4facfe; border-radius: 8px; }
        .result-item { margin-bottom: 15px; border-radius: 8px; overflow: hidden; transition: all 0.2s; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border: 1px solid #e0e0e0; background: white; }
        .result-item:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .result-item.added { border-left: 3px solid #28a745; }
        .result-item.deleted { border-left: 3px solid #dc3545; }
        .result-item.modified { border-left: 3px solid #ffc107; }
        .result-item.page-changed { border-left: 3px solid #007bff; }
        .result-item.unchanged { border-left: 3px solid #6c757d; }
        .result-header { padding: 10px 18px; font-weight: 600; font-size: 1em; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-bottom: 1px solid #e0e0e0; color: #2c3e50; }
        .result-body { padding: 15px 18px; background: white; }
        .change-box { margin-bottom: 16px; padding: 16px 18px; border-radius: 6px; font-family: 'Pretendard Variable', Pretendard, sans-serif; font-size: 14px; line-height: 1.5; font-weight: 500; color: #1a1a1a; border: 2px solid; letter-spacing: -0.02em; }
        .change-box:last-child { margin-bottom: 0; }
        .change-box.old { background: #ffffff; border-color: #ff4444; }
        .change-box.new { background: #ffffff; border-color: #44aa44; }
        .change-box.info { background: #ffffff; border-color: #4488ff; margin-top: 16px; }
        .change-box.same { background: #ffffff; border-color: #999999; }
        .change-label { font-weight: 600; margin-right: 8px; font-size: 13px; color: #2c2c2c; letter-spacing: -0.01em; }
        .original-text { font-family: 'Pretendard Variable', Pretendard, -apple-system, sans-serif; font-size: 14px; font-weight: 600; color: #1a1a1a; background: #f8f9fa; padding: 6px 10px; border-radius: 4px; display: inline-block; border: 1px solid #e9ecef; letter-spacing: -0.015em; line-height: 1.4; }
        .change-tags { margin-top: 14px; display: flex; flex-wrap: wrap; gap: 8px; }
        .change-tag { background: #2c3e50; color: #ffffff; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 600; border: none; box-shadow: 0 2px 4px rgba(44, 62, 80, 0.3); letter-spacing: -0.01em; }
        .urgent-badge { background: #e74c3c; color: white; padding: 4px 10px; border-radius: 10px; font-size: 12px; font-weight: 600; box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3); letter-spacing: -0.01em; }
        .no-results { text-align: center; padding: 60px 20px; color: #6c757d; }
        .no-results-icon { font-size: 3em; margin-bottom: 15px; }
        .no-results-title { font-size: 1.3em; font-weight: 600; margin-bottom: 8px; }
        .tips { background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); padding: 25px; border-radius: 12px; margin-top: 30px; border: 1px solid #bbdefb; }
        .tips h4 { color: #1565c0; font-size: 1.1em; margin-bottom: 15px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .tips-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; }
        .tip-item { display: flex; align-items: flex-start; gap: 8px; color: #1976d2; font-weight: 400; font-size: 0.9em; }
        .tip-icon { color: #4facfe; font-weight: 600; }
        @media (max-width: 768px) { .input-section { grid-template-columns: 1fr; gap: 20px; } .controls { flex-direction: column; gap: 15px; } .summary-stats { max-width: 100%; } .stat-card { min-width: 70px; } .tips-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“š ëª©ì°¨ ë¹„êµ ë¶„ì„</h1>
            <p>HWP/PDF ëª©ì°¨ ë³€ê²½ì‚¬í•­ì„ í¸ì§‘ì ìˆ˜ì¤€ìœ¼ë¡œ ì •ë°€ ë¶„ì„í•©ë‹ˆë‹¤</p>
        </div>
        <div class="content">
            <div class="input-section">
                <div class="input-box">
                    <div class="input-title">ğŸ“„ ê¸°ì¡´ ëª©ì°¨</div>
                    <textarea id="oldTOC" class="textarea" placeholder="ê¸°ì¡´ ëª©ì°¨ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ì–´ì£¼ì„¸ìš”.

ì˜ˆì‹œ:
ì œ1ì¥ ì„œë¡  ........................... 1
ì œ2ì¥ ì´ë¡ ì  ë°°ê²½ .................... 15
  2.1 ì„ í–‰ì—°êµ¬ ....................... 16
  2.2 ì—°êµ¬ëª¨í˜• ....................... 25
ì œ3ì¥ ì—°êµ¬ë°©ë²• ....................... 35"></textarea>
                    <div class="count" id="oldCount">0ì¤„</div>
                </div>
                <div class="input-box">
                    <div class="input-title">ğŸ“ ìƒˆë¡œìš´ ëª©ì°¨</div>
                    <textarea id="newTOC" class="textarea" placeholder="ìƒˆë¡œìš´ ëª©ì°¨ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ì–´ì£¼ì„¸ìš”.

ì˜ˆì‹œ:
ì œ1ì¥ ì„œë¡  ........................... 1
ì œ2ì¥ ì´ë¡ ì  ë°°ê²½ ë° ì„ í–‰ì—°êµ¬ ........ 15
  2.1 ì„ í–‰ì—°êµ¬ ê²€í†  .................. 16
  2.2 ì—°êµ¬ëª¨í˜• ì„¤ì • .................. 25
ì œ3ì¥ ì—°êµ¬ë°©ë²•ë¡  ..................... 35
ì œ4ì¥ ì—°êµ¬ê²°ê³¼ ....................... 50"></textarea>
                    <div class="count" id="newCount">0ì¤„</div>
                </div>
            </div>
            <div class="compare-section">
                <button class="compare-btn" id="compareBtn">ğŸ” ëª©ì°¨ ë¹„êµ ë¶„ì„ ì‹œì‘</button>
            </div>
            <div class="results" id="results">
                <div class="controls">
                    <div class="filter-group">
                        <button class="filter-btn active" data-filter="changes">ë³€ê²½ì‚¬í•­</button>
                        <button class="filter-btn" data-filter="all">ì „ì²´</button>
                        <button class="filter-btn" data-filter="urgent">ê¸´ê¸‰ê²€í† </button>
                    </div>
                    <div class="summary-stats">
                        <div class="stat-card total"><div class="stat-number" id="totalCount">0</div><div class="stat-label">ì´ í•­ëª©</div></div>
                        <div class="stat-card added"><div class="stat-number" id="addedCount">0</div><div class="stat-label">â• ì¶”ê°€</div></div>
                        <div class="stat-card deleted"><div class="stat-number" id="deletedCount">0</div><div class="stat-label">â– ì‚­ì œ</div></div>
                        <div class="stat-card modified"><div class="stat-number" id="modifiedCount">0</div><div class="stat-label">âœï¸ ìˆ˜ì •</div></div>
                        <div class="stat-card urgent"><div class="stat-number" id="urgentCount">0</div><div class="stat-label">ğŸš¨ ê¸´ê¸‰</div></div>
                    </div>
                    <button class="copy-btn" id="copyBtn">ğŸ“‹ ê²°ê³¼ ë³µì‚¬</button>
                </div>
                <div class="results-list" id="resultsList"></div>
            </div>
            <div class="tips">
                <h4>ğŸ’¡ í¸ì§‘ì ìˆ˜ì¤€ ë¶„ì„ ê¸°ëŠ¥</h4>
                <div class="tips-grid">
                    <div class="tip-item"><span class="tip-icon">â–¶</span><span>ë„ì–´ì“°ê¸°, ë¬¸ì¥ë¶€í˜¸, ì¡°ì‚¬ ë³€ê²½ê¹Œì§€ ì •ë°€ ê°ì§€</span></div>
                    <div class="tip-item"><span class="tip-icon">â–¶</span><span>í•œìí‘œê¸°, ì™¸ë˜ì–´ í‘œê¸°ë²•, ì „ë¬¸ìš©ì–´ ë³€ê²½ ë¶„ì„</span></div>
                    <div class="tip-item"><span class="tip-icon">â–¶</span><span>ë‹¨ì–´ ì¶”ê°€/ì‚­ì œ/ìˆœì„œë³€ê²½, ì–´ë¯¸ ë³€í™” ê°ì§€</span></div>
                    <div class="tip-item"><span class="tip-icon">â–¶</span><span>êµì •êµì—´ ì „ë¬¸ê°€ ìˆ˜ì¤€ì˜ ì„¸ë°€í•œ í…ìŠ¤íŠ¸ ë¹„êµ</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let analysisResults = [];
        let currentFilter = 'changes';

        document.addEventListener('DOMContentLoaded', function() {
            const oldTOC = document.getElementById('oldTOC');
            const newTOC = document.getElementById('newTOC');
            const compareBtn = document.getElementById('compareBtn');
            const copyBtn = document.getElementById('copyBtn');
            const filterBtns = document.querySelectorAll('.filter-btn');

            oldTOC.addEventListener('input', () => updateLineCount('oldTOC', 'oldCount'));
            newTOC.addEventListener('input', () => updateLineCount('newTOC', 'newCount'));
            compareBtn.addEventListener('click', startComparison);
            copyBtn.addEventListener('click', copyResults);

            filterBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setFilter(e.target.dataset.filter);
                });
            });

            updateLineCount('oldTOC', 'oldCount');
            updateLineCount('newTOC', 'newCount');
        });

        function updateLineCount(textareaId, countId) {
            const textarea = document.getElementById(textareaId);
            const lines = textarea.value.split('\n').filter(line => line.trim().length > 0);
            document.getElementById(countId).textContent = lines.length + 'ì¤„';
        }

        function parseTOC(text) {
            if (!text.trim()) return [];
            // ë¹ˆ ì¤„ ì œê±° ë° ì—°ì†ëœ ê³µë°± ì •ë¦¬
            const lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            return lines.map((line, index) => {
                const trimmed = line.trim();
                const indent = line.length - line.trimStart().length;
                const level = Math.floor(indent / 2);
                const patterns = [/^(.+?)\s*[\.]{2,}\s*(\d+)$/, /^(.+?)\s{3,}(\d+)$/, /^(.+?)\t+(\d+)$/, /^(.+?)\s*\((\d+)\)$/, /^(.+?)\s*[-~]\s*(\d+)$/];
                let title = '', page = '';
                for (const pattern of patterns) {
                    const match = trimmed.match(pattern);
                    if (match) { title = match[1].trim(); page = match[2]; break; }
                }
                if (!title) title = trimmed;
                title = title.replace(/^[\d\.\-\s]*/, '').trim().replace(/[\.]{2,}$/, '').trim();
                return { index, title, page, level, original: trimmed };
            });
        }

        function calculateSimilarity(str1, str2) {
            if (str1 === str2) return 1.0;
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;
            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = Array(str2.length + 1).fill().map(() => Array(str1.length + 1).fill(0));
            for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
            for (let j = 1; j <= str2.length; j++) {
                for (let i = 1; i <= str1.length; i++) {
                    if (str1[i - 1] === str2[j - 1]) matrix[j][i] = matrix[j - 1][i - 1];
                    else matrix[j][i] = Math.min(matrix[j - 1][i - 1] + 1, matrix[j][i - 1] + 1, matrix[j - 1][i] + 1);
                }
            }
            return matrix[str2.length][str1.length];
        }

        function detectParticleChanges(oldText, newText) {
            const changes = [];
            const particles = [
                {old: 'ì€', new: 'ëŠ”', desc: 'ì£¼ê²©ì¡°ì‚¬'},
                {old: 'ì´', new: 'ê°€', desc: 'ì£¼ê²©ì¡°ì‚¬'},
                {old: 'ì„', new: 'ë¥¼', desc: 'ëª©ì ê²©ì¡°ì‚¬'},
                {old: 'ì™€', new: 'ê³¼', desc: 'ì ‘ì†ì¡°ì‚¬'},
                {old: 'ë¡œ', new: 'ìœ¼ë¡œ', desc: 'ë¶€ì‚¬ê²©ì¡°ì‚¬'}
            ];
            
            particles.forEach(({old, new: newParticle, desc}) => {
                if (oldText.includes(old) && newText.includes(newParticle)) {
                    changes.push(`${desc} ë³€ê²½ (${old}â†’${newParticle})`);
                } else if (oldText.includes(newParticle) && newText.includes(old)) {
                    changes.push(`${desc} ë³€ê²½ (${newParticle}â†’${old})`);
                }
            });
            
            return changes;
        }

        function detectEndingChanges(oldText, newText) {
            const changes = [];
            const endings = [
                {old: 'ìŠµë‹ˆë‹¤', new: 'ã…‚ë‹ˆë‹¤', desc: 'ì„œìˆ ì–´ë¯¸'},
                {old: 'í–ˆë‹¤', new: 'í•˜ì˜€ë‹¤', desc: 'ê³¼ê±°í˜•'},
                {old: 'í•œë‹¤', new: 'í•¨', desc: 'í˜„ì¬í˜•'},
                {old: 'ê²ƒì´ë‹¤', new: 'ê²ƒì„', desc: 'ì„œìˆ í˜•'},
                {old: 'ë˜ì—ˆë‹¤', new: 'ëë‹¤', desc: 'ì¶•ì•½í˜•'}
            ];
            
            endings.forEach(({old, new: newEnding, desc}) => {
                if (oldText.includes(old) && newText.includes(newEnding)) {
                    changes.push(`${desc} ë³€ê²½ (${old}â†’${newEnding})`);
                } else if (oldText.includes(newEnding) && newText.includes(old)) {
                    changes.push(`${desc} ë³€ê²½ (${newEnding}â†’${old})`);
                }
            });
            
            return changes;
        }

        function analyzeWordChanges(oldText, newText) {
            const changes = [];
            const oldWords = oldText.split(/[\s\.,\(\)]+/).filter(w => w.length > 0);
            const newWords = newText.split(/[\s\.,\(\)]+/).filter(w => w.length > 0);
            
            const addedWords = newWords.filter(word => !oldWords.includes(word));
            if (addedWords.length > 0) {
                changes.push(`ë‹¨ì–´ ì¶”ê°€: "${addedWords.join(', ')}"`);
            }
            
            const deletedWords = oldWords.filter(word => !newWords.includes(word));
            if (deletedWords.length > 0) {
                changes.push(`ë‹¨ì–´ ì‚­ì œ: "${deletedWords.join(', ')}"`);
            }
            
            const commonWords = oldWords.filter(word => newWords.includes(word));
            if (commonWords.length > 1) {
                const oldOrder = commonWords.map(word => oldWords.indexOf(word));
                const newOrder = commonWords.map(word => newWords.indexOf(word));
                if (JSON.stringify(oldOrder) !== JSON.stringify(newOrder)) {
                    changes.push('ë‹¨ì–´ ìˆœì„œ ë³€ê²½');
                }
            }
            
            return changes;
        }

        function detectNotationChanges(oldText, newText) {
            const changes = [];
            
            const foreignWords = [
                {old: 'ì»´í“¨í„°', new: 'computer', desc: 'ì™¸ë˜ì–´â†’ì˜ë¬¸'},
                {old: 'computer', new: 'ì»´í“¨í„°', desc: 'ì˜ë¬¸â†’ì™¸ë˜ì–´'},
                {old: 'ë°ì´íƒ€', new: 'ë°ì´í„°', desc: 'ì™¸ë˜ì–´ í‘œê¸°ë²•'},
                {old: 'í”„ë¡œê·¸ë¨', new: 'í”„ë¡œê·¸ë˜ë°', desc: 'ì™¸ë˜ì–´ í™œìš©í˜•'},
                {old: 'ì‹œìŠ¤í…œ', new: 'ì²´ê³„', desc: 'ì™¸ë˜ì–´â†’ìˆœìš°ë¦¬ë§'},
                {old: 'ë§¤ë‹ˆì ¸', new: 'ë§¤ë‹ˆì €', desc: 'ì™¸ë˜ì–´ í‘œê¸°ë²•'}
            ];
            
            foreignWords.forEach(({old, new: newWord, desc}) => {
                if (oldText.includes(old) && newText.includes(newWord)) {
                    changes.push(`${desc} (${old}â†’${newWord})`);
                }
            });
            
            const terminology = [
                {old: 'ë¶„ì„', new: 'í•´ì„', desc: 'ìš©ì–´ ì„ íƒ'},
                {old: 'ë°©ë²•', new: 'ë°©ë²•ë¡ ', desc: 'í•™ìˆ ì  í‘œí˜„'},
                {old: 'ì—°êµ¬', new: 'ì¡°ì‚¬', desc: 'ìš©ì–´ ì •ë°€í™”'},
                {old: 'ê²°ê³¼', new: 'ì„±ê³¼', desc: 'ë‰˜ì•™ìŠ¤ ë³€ê²½'}
            ];
            
            terminology.forEach(({old, new: newTerm, desc}) => {
                if (oldText.includes(old) && newText.includes(newTerm)) {
                    changes.push(`${desc} (${old}â†’${newTerm})`);
                }
            });
            
            return changes;
        }

        function analyzeNumberChanges(oldItem, newItem) {
            const changes = [];
            
            const chapterPatterns = [/ì œ?(\d+)ì¥/g, /ì œ(\d+)/g];
            let foundChapterChange = false;
            
            for (const pattern of chapterPatterns) {
                const oldNumbers = oldItem.title.match(pattern);
                const newNumbers = newItem.title.match(pattern);
                
                if (oldNumbers && newNumbers && oldNumbers[0] !== newNumbers[0] && !foundChapterChange) {
                    const oldNum = oldNumbers[0].match(/\d+/)[0];
                    const newNum = newNumbers[0].match(/\d+/)[0];
                    changes.push(`ì¥ ë²ˆí˜¸ ë³€ê²½ (${oldNum}â†’${newNum})`);
                    foundChapterChange = true;
                    break;
                }
            }
            
            const otherPatterns = [
                { pattern: /(\d+)ì ˆ/g, name: 'ì ˆ' },
                { pattern: /(\d+)í•­/g, name: 'í•­' },
                { pattern: /(\d+)ë¶€/g, name: 'ë¶€' },
                { pattern: /(\d+)ì°¨/g, name: 'ì°¨' },
                { pattern: /(\d+)í¸/g, name: 'í¸' }
            ];
            
            otherPatterns.forEach(({ pattern, name }) => {
                const oldNumbers = oldItem.title.match(pattern);
                const newNumbers = newItem.title.match(pattern);
                if (oldNumbers && newNumbers && oldNumbers[0] !== newNumbers[0]) {
                    const oldNum = oldNumbers[0].match(/\d+/)[0];
                    const newNum = newNumbers[0].match(/\d+/)[0];
                    changes.push(`${name} ë²ˆí˜¸ ë³€ê²½ (${oldNum}â†’${newNum})`);
                }
            });
            
            return changes;
        }
        
        function analyzeChanges(oldItem, newItem) {
            const changes = [];
            const oldText = oldItem.title;
            const newText = newItem.title;
            
            if (oldText === newText) {
                // ì œëª©ì´ ê°™ìœ¼ë©´ í˜ì´ì§€ ë³€ê²½ë§Œ í™•ì¸
                if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                    changes.push(`í˜ì´ì§€ ë³€ê²½ (${oldItem.page}â†’${newItem.page})`);
                }
                return changes;
            }
            
            // ì œëª©ì´ ë‹¤ë¥´ë©´ ìƒì„¸ ë¶„ì„
            const detailChanges = analyzeDetailChanges(oldText, newText);
            changes.push(...detailChanges);
            
            // í˜ì´ì§€ë„ ë‹¤ë¥´ë©´ ì¶”ê°€
            if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                changes.push(`í˜ì´ì§€ ë³€ê²½ (${oldItem.page}â†’${newItem.page})`);
            }
            
            return changes.length > 0 ? changes : ['ë‚´ìš© ìˆ˜ì •'];
        }

        function analyzeDetailChanges(oldText, newText) {
            const changes = [];
            
            // ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë¶„ì„í•˜ì—¬ ì •í™•í•œ ë³€ê²½ ë¶€ë¶„ ì°¾ê¸°
            const oldWords = oldText.split(/\s+/);
            const newWords = newText.split(/\s+/);
            
            // ê°€ì¥ ê¸´ ê³µí†µ ë¶€ë¶„ ì°¾ê¸°
            const commonPrefix = findCommonPrefix(oldWords, newWords);
            const commonSuffix = findCommonSuffix(oldWords, newWords);
            
            // ë³€ê²½ëœ ë¶€ë¶„ ì¶”ì¶œ
            const oldChanged = oldWords.slice(commonPrefix.length, oldWords.length - commonSuffix.length);
            const newChanged = newWords.slice(commonPrefix.length, newWords.length - commonSuffix.length);
            
            if (oldChanged.length > 0 || newChanged.length > 0) {
                const oldPart = oldChanged.join(' ') || '';
                const newPart = newChanged.join(' ') || '';
                
                if (oldPart && newPart) {
                    changes.push(`ë‚´ìš©ìˆ˜ì •: ${oldPart}â†’${newPart}`);
                } else if (oldPart && !newPart) {
                    changes.push(`ì‚­ì œ: ${oldPart}`);
                } else if (!oldPart && newPart) {
                    changes.push(`ì¶”ê°€: ${newPart}`);
                }
            }
            
            // ë§Œì•½ ë‹¨ì–´ ë‹¨ìœ„ë¡œ ì°¾ì§€ ëª»í–ˆë‹¤ë©´ ë¬¸ì ë‹¨ìœ„ë¡œ ë¶„ì„
            if (changes.length === 0 && oldText !== newText) {
                const charChanges = findCharacterChanges(oldText, newText);
                if (charChanges) {
                    changes.push(charChanges);
                }
            }
            
            return changes;
        }

        function findCommonPrefix(arr1, arr2) {
            const common = [];
            const minLength = Math.min(arr1.length, arr2.length);
            for (let i = 0; i < minLength; i++) {
                if (arr1[i] === arr2[i]) {
                    common.push(arr1[i]);
                } else {
                    break;
                }
            }
            return common;
        }

        function findCommonSuffix(arr1, arr2) {
            const common = [];
            const minLength = Math.min(arr1.length, arr2.length);
            for (let i = 0; i < minLength; i++) {
                const oldIndex = arr1.length - 1 - i;
                const newIndex = arr2.length - 1 - i;
                if (arr1[oldIndex] === arr2[newIndex]) {
                    common.unshift(arr1[oldIndex]);
                } else {
                    break;
                }
            }
            return common;
        }

        function findCharacterChanges(oldText, newText) {
            // ë¬¸ì ë‹¨ìœ„ë¡œ ë¹„êµí•˜ì—¬ ê°€ì¥ ì‘ì€ ë³€ê²½ ë¶€ë¶„ ì°¾ê¸°
            let start = 0;
            let end = 0;
            
            // ì•ì—ì„œë¶€í„° ê°™ì€ ë¶€ë¶„ ì°¾ê¸°
            while (start < oldText.length && start < newText.length && oldText[start] === newText[start]) {
                start++;
            }
            
            // ë’¤ì—ì„œë¶€í„° ê°™ì€ ë¶€ë¶„ ì°¾ê¸°
            while (end < oldText.length - start && end < newText.length - start && 
                   oldText[oldText.length - 1 - end] === newText[newText.length - 1 - end]) {
                end++;
            }
            
            const oldChanged = oldText.slice(start, oldText.length - end);
            const newChanged = newText.slice(start, newText.length - end);
            
            if (oldChanged && newChanged) {
                return `ë‚´ìš©ìˆ˜ì •: ${oldChanged}â†’${newChanged}`;
            } else if (oldChanged) {
                return `ì‚­ì œ: ${oldChanged}`;
            } else if (newChanged) {
                return `ì¶”ê°€: ${newChanged}`;
            }
            
            return null;
        }

        function analyzeTextChanges(oldText, newText) {
            const changes = [];
            
            if (oldText === newText) return [];
            
            const oldSpaces = oldText.replace(/[^\s]/g, '');
            const newSpaces = newText.replace(/[^\s]/g, '');
            if (oldSpaces !== newSpaces) {
                changes.push('ë„ì–´ì“°ê¸° ìˆ˜ì •');
            }
            
            const oldPunct = oldText.replace(/[^\.,!?;:()]/g, '');
            const newPunct = newText.replace(/[^\.,!?;:()]/g, '');
            if (oldPunct !== newPunct) {
                changes.push('ë¬¸ì¥ë¶€í˜¸ ìˆ˜ì •');
            }
            
            const hanjaPattern = /[ä¸€-é¾¯]/;
            const oldHasHanja = hanjaPattern.test(oldText);
            const newHasHanja = hanjaPattern.test(newText);
            if (oldHasHanja !== newHasHanja) {
                if (newHasHanja) changes.push('í•œì í‘œê¸° ì¶”ê°€');
                else changes.push('í•œì í‘œê¸° ì œê±°');
            }
            
            const particleChanges = detectParticleChanges(oldText, newText);
            changes.push(...particleChanges);
            
            const endingChanges = detectEndingChanges(oldText, newText);
            changes.push(...endingChanges);
            
            const wordChanges = analyzeWordChanges(oldText, newText);
            changes.push(...wordChanges);
            
            const notationChanges = detectNotationChanges(oldText, newText);
            changes.push(...notationChanges);
            
            return changes;
        }

        function analyzePageChanges(oldItem, newItem) {
            const changes = [];
            
            if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                const oldPageNum = parseInt(oldItem.page);
                const newPageNum = parseInt(newItem.page);
                const pageDiff = Math.abs(newPageNum - oldPageNum);
                
                if (pageDiff > 20) {
                    changes.push(`í˜ì´ì§€ ëŒ€í­ ë³€ê²½ (${oldItem.page}â†’${newItem.page})`);
                } else if (pageDiff > 5) {
                    changes.push(`í˜ì´ì§€ ìƒë‹¹ ë³€ê²½ (${oldItem.page}â†’${newItem.page})`);
                } else {
                    changes.push(`í˜ì´ì§€ ì†Œí­ ë³€ê²½ (${oldItem.page}â†’${newItem.page})`);
                }
            }
            
            return changes;
        }
        
        function compareItems(oldItems, newItems) {
            const results = [];
            const usedOld = new Set();
            const usedNew = new Set();
            
            // 1ë‹¨ê³„: ì œëª©ê³¼ ìˆœì„œê°€ ì™„ì „íˆ ì¼ì¹˜í•˜ëŠ” í•­ëª©ë“¤ ë§¤ì¹­
            oldItems.forEach((oldItem, oldIndex) => {
                if (oldIndex < newItems.length) {
                    const newItem = newItems[oldIndex];
                    if (oldItem.title === newItem.title) {
                        usedOld.add(oldIndex);
                        usedNew.add(oldIndex);
                        const changes = [];
                        if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                            changes.push(`í˜ì´ì§€ ${oldItem.page} â†’ ${newItem.page}`);
                        }
                        results.push({ 
                            type: changes.length > 0 ? 'page-changed' : 'unchanged', 
                            oldItem, 
                            newItem, 
                            changes, 
                            severity: 'low', 
                            position: oldIndex 
                        });
                    }
                }
            });
            
            // 2ë‹¨ê³„: ì œëª©ì´ ê°™ì§€ë§Œ ìœ„ì¹˜ê°€ ë‹¤ë¥¸ í•­ëª©ë“¤ ë§¤ì¹­
            oldItems.forEach((oldItem, oldIndex) => {
                if (usedOld.has(oldIndex)) return;
                
                for (let newIndex = 0; newIndex < newItems.length; newIndex++) {
                    if (usedNew.has(newIndex)) continue;
                    
                    const newItem = newItems[newIndex];
                    if (oldItem.title === newItem.title) {
                        usedOld.add(oldIndex);
                        usedNew.add(newIndex);
                        const changes = ['ìœ„ì¹˜ ë³€ê²½'];
                        if (oldItem.page !== newItem.page && oldItem.page && newItem.page) {
                            changes.push(`í˜ì´ì§€ ${oldItem.page} â†’ ${newItem.page}`);
                        }
                        results.push({ 
                            type: 'page-changed', 
                            oldItem, 
                            newItem, 
                            changes, 
                            severity: 'medium', 
                            position: Math.min(oldIndex, newIndex) 
                        });
                        break;
                    }
                }
            });
            
            // 3ë‹¨ê³„: ìœ ì‚¬í•œ ì œëª©ì˜ í•­ëª©ë“¤ ë§¤ì¹­ (70% ì´ìƒ ìœ ì‚¬ë„)
            oldItems.forEach((oldItem, oldIndex) => {
                if (usedOld.has(oldIndex)) return;
                
                let bestMatch = null, bestSimilarity = 0, bestNewIndex = -1;
                newItems.forEach((newItem, newIndex) => {
                    if (usedNew.has(newIndex)) return;
                    const similarity = calculateSimilarity(oldItem.title.toLowerCase(), newItem.title.toLowerCase());
                    if (similarity > bestSimilarity && similarity > 0.7) {
                        bestMatch = newItem;
                        bestSimilarity = similarity;
                        bestNewIndex = newIndex;
                    }
                });
                
                if (bestMatch) {
                    usedOld.add(oldIndex);
                    usedNew.add(bestNewIndex);
                    const changes = analyzeChanges(oldItem, bestMatch);
                    results.push({ 
                        type: 'modified', 
                        oldItem, 
                        newItem: bestMatch, 
                        changes, 
                        severity: 'medium', 
                        position: Math.min(oldIndex, bestNewIndex) 
                    });
                }
            });
            
            // 4ë‹¨ê³„: ì‚­ì œëœ í•­ëª©ë“¤
            oldItems.forEach((oldItem, oldIndex) => {
                if (!usedOld.has(oldIndex)) {
                    results.push({ 
                        type: 'deleted', 
                        oldItem, 
                        newItem: null, 
                        changes: ['ì‚­ì œë¨'], 
                        severity: 'high', 
                        position: oldIndex 
                    });
                }
            });
            
            // 5ë‹¨ê³„: ì¶”ê°€ëœ í•­ëª©ë“¤
            newItems.forEach((newItem, newIndex) => {
                if (!usedNew.has(newIndex)) {
                    results.push({ 
                        type: 'added', 
                        oldItem: null, 
                        newItem, 
                        changes: ['ìƒˆë¡œ ì¶”ê°€ë¨'], 
                        severity: 'medium', 
                        position: newIndex 
                    });
                }
            });
            
            return results.sort((a, b) => a.position - b.position);
        }

        function startComparison() {
            const oldText = document.getElementById('oldTOC').value;
            const newText = document.getElementById('newTOC').value;
            if (!oldText.trim() || !newText.trim()) { 
                alert('ê¸°ì¡´ ëª©ì°¨ì™€ ìƒˆë¡œìš´ ëª©ì°¨ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.'); 
                return; 
            }
            const btn = document.getElementById('compareBtn');
            btn.disabled = true;
            btn.textContent = 'ğŸ”„ ë¶„ì„ì¤‘...';
            setTimeout(() => {
                const oldItems = parseTOC(oldText);
                const newItems = parseTOC(newText);
                analysisResults = compareItems(oldItems, newItems);
                displayResults();
                btn.disabled = false;
                btn.textContent = 'ğŸ” ëª©ì°¨ ë¹„êµ ë¶„ì„ ì‹œì‘';
            }, 500);
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.classList.add('show');
            const stats = {
                total: analysisResults.length,
                added: analysisResults.filter(r => r.type === 'added').length,
                deleted: analysisResults.filter(r => r.type === 'deleted').length,
                modified: analysisResults.filter(r => r.type === 'modified' || r.type === 'page-changed').length,
                urgent: analysisResults.filter(r => r.severity === 'high').length
            };
            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('addedCount').textContent = stats.added;
            document.getElementById('deletedCount').textContent = stats.deleted;
            document.getElementById('modifiedCount').textContent = stats.modified;
            document.getElementById('urgentCount').textContent = stats.urgent;
            updateResultsList();
        }

        function setFilter(filter) {
            currentFilter = filter;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
            updateResultsList();
        }

        function updateResultsList() {
            const resultsListDiv = document.getElementById('resultsList');
            let filteredResults = analysisResults;
            if (currentFilter === 'changes') {
                filteredResults = analysisResults.filter(r => r.type !== 'unchanged');
            } else if (currentFilter === 'urgent') {
                filteredResults = analysisResults.filter(r => r.severity === 'high');
            }
            
            if (filteredResults.length === 0) {
                resultsListDiv.innerHTML = '<div class="no-results"><div class="no-results-icon">âœ…</div><div class="no-results-title">í‘œì‹œí•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤</div></div>';
                return;
            }
            
            resultsListDiv.innerHTML = filteredResults.map((result, index) => {
                const typeLabels = { 
                    'added': 'â• ì¶”ê°€ë¨', 
                    'deleted': 'â– ì‚­ì œë¨', 
                    'modified': 'âœï¸ ìˆ˜ì •ë¨', 
                    'page-changed': 'ğŸ“„ í˜ì´ì§€ ë³€ê²½', 
                    'unchanged': 'âœ… ë™ì¼' 
                };
                
                let bodyHtml = '';
                if (result.type === 'added') {
                    bodyHtml = `<div class="change-box new"><span class="change-label">ìƒˆë¡œ ì¶”ê°€:</span> <span class="original-text">${result.newItem.original}</span></div>`;
                } else if (result.type === 'deleted') {
                    bodyHtml = `<div class="change-box old"><span class="change-label">ì‚­ì œë¨:</span> <span class="original-text">${result.oldItem.original}</span></div>`;
                } else if (result.type === 'modified') {
                    let formattedChanges = '';
                    result.changes.forEach(change => {
                        if (change.startsWith('ë‚´ìš©ìˆ˜ì •:')) {
                            const content = change.substring(5).trim();
                            if (content.includes('â†’')) {
                                const [before, after] = content.split('â†’');
                                formattedChanges += `<span class="change-item"><span class="change-tag">ë‚´ìš©ìˆ˜ì •</span> <span class="change-content"><span class="change-before">${before.trim()}</span><span class="change-arrow"> â†’ </span><span class="change-after">${after.trim()}</span></span></span>`;
                            } else {
                                formattedChanges += `<span class="change-item"><span class="change-tag">ë‚´ìš©ìˆ˜ì •</span> <span class="change-content">${content}</span></span>`;
                            }
                        } else if (change.startsWith('ì¶”ê°€:')) {
                            const content = change.substring(3).trim();
                            formattedChanges += `<span class="change-item"><span class="change-tag">ì¶”ê°€</span> <span class="change-content"><span class="change-after">${content}</span></span></span>`;
                        } else if (change.startsWith('ì‚­ì œ:')) {
                            const content = change.substring(3).trim();
                            formattedChanges += `<span class="change-item"><span class="change-tag">ì‚­ì œ</span> <span class="change-content"><span class="change-before">${content}</span></span></span>`;
                        } else {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        }
                    });
                    
                    bodyHtml = `
                        <div class="change-box old"><span class="change-label">ì´ì „ ë‚´ìš©:</span> <span class="original-text">${result.oldItem.original}</span></div>
                        <div class="change-box new"><span class="change-label">ìˆ˜ì •ëœ ë‚´ìš©:</span> <span class="original-text">${result.newItem.original}</span></div>
                        <div class="change-box info"><span class="change-label">ğŸ” ë³€ê²½ì‚¬í•­: </span>${formattedChanges}</div>
                    `;
                } else if (result.type === 'page-changed') {
                    let formattedChanges = '';
                    result.changes.forEach(change => {
                        if (change.startsWith('ìœ„ì¹˜ ë³€ê²½')) {
                            formattedChanges += `<span class="change-item"><span class="change-tag">ìœ„ì¹˜ ë³€ê²½</span></span>`;
                        } else if (change.startsWith('í˜ì´ì§€')) {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        } else {
                            formattedChanges += `<span class="change-item"><span class="change-tag">${change}</span></span>`;
                        }
                    });
                    
                    bodyHtml = `
                        <div class="change-box old"><span class="change-label">ì´ì „:</span> <span class="original-text">${result.oldItem.original}</span></div>
                        <div class="change-box new"><span class="change-label">ì´í›„:</span> <span class="original-text">${result.newItem.original}</span></div>
                        <div class="change-box info"><span class="change-label">ğŸ” ë³€ê²½ì‚¬í•­: </span>${formattedChanges}</div>
                    `;
                } else {
                    bodyHtml = `<div class="change-box same"><span class="change-label">ë™ì¼:</span> <span class="original-text">${result.oldItem.original}</span></div>`;
                }
                
                return `<div class="result-item ${result.type}"><div class="result-header ${result.type}"><span>${typeLabels[result.type]} #${index + 1}</span>${result.severity === 'high' ? '<span class="urgent-badge">ğŸš¨ ê¸´ê¸‰</span>' : ''}</div><div class="result-body">${bodyHtml}</div></div>`;
            }).join('');
        }

        // formatChanges í•¨ìˆ˜ ì œê±° (ì¸ë¼ì¸ìœ¼ë¡œ ì²˜ë¦¬í•˜ë¯€ë¡œ ë¶ˆí•„ìš”)

        function copyResults() {
            if (analysisResults.length === 0) { 
                alert('ë¹„êµ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.'); 
                return; 
            }
            
            // í˜„ì¬ í•„í„°ì— ë”°ë¼ ê²°ê³¼ í•„í„°ë§
            let filteredResults = analysisResults;
            let filterLabel = 'ì „ì²´';
            
            if (currentFilter === 'changes') {
                filteredResults = analysisResults.filter(r => r.type !== 'unchanged');
                filterLabel = 'ë³€ê²½ì‚¬í•­';
            } else if (currentFilter === 'urgent') {
                filteredResults = analysisResults.filter(r => r.severity === 'high');
                filterLabel = 'ê¸´ê¸‰ê²€í† ';
            }
            
            if (filteredResults.length === 0) {
                alert('í˜„ì¬ í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            let text = `ëª©ì°¨ ë¹„êµ ë¶„ì„ ê²°ê³¼ (${filterLabel})\nìƒì„±ì¼ì‹œ: ` + new Date().toLocaleString('ko-KR') + '\n\n';
            filteredResults.forEach((result, index) => {
                const typeLabels = { 
                    'added': 'â• ì¶”ê°€ë¨', 
                    'deleted': 'â– ì‚­ì œë¨', 
                    'modified': 'âœï¸ ìˆ˜ì •ë¨', 
                    'page-changed': 'ğŸ“„ í˜ì´ì§€ ë³€ê²½', 
                    'unchanged': 'âœ… ë™ì¼' 
                };
                
                text += `${index + 1}. ${typeLabels[result.type]}${result.severity === 'high' ? ' ğŸš¨ ê¸´ê¸‰' : ''}\n`;
                if (result.oldItem) text += `   ê¸°ì¡´: ${result.oldItem.original}\n`;
                if (result.newItem) text += `   ìƒˆë¡œ: ${result.newItem.original}\n`;
                if (result.changes && result.changes.length > 0) text += `   ë³€ê²½ì‚¬í•­: ${result.changes.join(', ')}\n`;
                text += '\n';
            });
            
            text += 'â€» í¸ì§‘ì ìˆ˜ì¤€ ëª©ì°¨ ë¹„êµ ë¶„ì„ê¸°ì—ì„œ ìƒì„±ë¨';
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    alert(`${filterLabel} ë¶„ì„ ê²°ê³¼ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! (${filteredResults.length}ê°œ í•­ëª©)`);
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                alert('ë¶„ì„ ê²°ê³¼ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            } catch (err) {
                alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œ ë³µì‚¬í•´ì£¼ì„¸ìš”.');
            }
            document.body.removeChild(textArea);
        }
    </script>
</body>
</html>
